#!/bin/bash
###
# pkgfile -- search the arch repo to see what package owns a file
# This program is a part of pkgtools

# Copyright (C) 2008-2010 Daenyth <Daenyth+Arch _AT_ gmail _DOT_ com>
#
# Pkgtools is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# Pkgtools is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
##

###
# You can change these values in the config file
##
PKGTOOLS_DIR='/usr/share/pkgtools/'
CONFIG_DIR='/etc/pkgtools/'
FILELIST_DIR='/var/cache/pkgtools/lists'
LOCKFILE='/var/lock/pkgfile'
RATELIMIT= # Argument to wget's --limit-rate flag

if [[ -r $PKGTOOLS_DIR/functions ]]; then
        source "$PKGTOOLS_DIR/functions"
else
        printf "Unable to source function file!\n" >&2
        exit 1
fi

###
# You should not change below this point
##
VERBOSE=0
DEBUG=0
REMOTE_SEARCH=0 # Force remote search instead of using pacman database
BINARIES=0 # Search for binaries (files in a bin or sbin directory).
GLOBBING=0 # Allow a search to use globs; * and ? as basic wildcards
CASE_SENSITIVE=0 # Case sensitive filename searching?
DEFAULT_ACTION=search

load_config 'pkgfile.conf'

readonly MYVERSION=11.0
SEARCHTARGET=
ACTION=
UPDATE=0
PROGNAME="$(basename $0)"

umask 0022 # This will ensure that any files we create are readable by normal users

# cd_filelist_dir() {{{
cd_filelist_dir () {
        [[ 'noempty' != "$1" ]] && check_filelist_dir

        cd "$FILELIST_DIR" || die 1 "Unable to change directory to %s\n" $FILELIST_DIR
        if [[ $1 == 'noempty' ]]; then
                # */* expanded is really ugly
                (( DEBUG >= 2 )) && set +x
                # TODO: De-uglify
                if echo */* | grep -q '^\*/\*$'; then
                        die 1 "%s appears to be empty! Did you run %s --update?\n" "$FILELIST_DIR" "$PROGNAME"
                fi
        fi
        (( DEBUG >= 2 )) && set -x
}
# }}}

# check_filelist_dir() -- Check for existance and correct pemissions for $FILELIST_DIR {{{
check_filelist_dir () {
                if [[ ! -d "$FILELIST_DIR" ]]; then
                        warn "%s does not exist -- creating " $FILELIST_DIR
                        mkdir -p "$FILELIST_DIR" || die 1 "Could not create %s\n" $FILELIST_DIR
                fi
                if [[ ! -w "$FILELIST_DIR" ]];then
                        die 1 "No write permission to %s, try somewhere else\n" "$FILELIST_DIR"
                fi
}
# }}}

# regex_escape() -- Takes a string and returns an version with regex metacharacters escaped (For grep -E) {{{
regex_escape () {
        if (( GLOBBING )); then
                echo "$1" | sed -e 's|[].+$^{}\|[]|\\&|g' -e 's|[*]|[^/]*|g; s|[?]|.|g'
        else
                echo "$1" | sed -e 's|[].+*?$^{}\|[]|\\&|g'
        fi
}
# }}}

# usage() {{{
usage () {

#           |--------------------------------------------------------------------------------| 80 Characters
        msg "%s version %s -- Find which package owns a file\n" "$PROGNAME" $MYVERSION
        msg "Usage: %s [ACTIONS] [OPTIONS] filename\n" "$PROGNAME"
        msg "ACTIONS:\n"
        msg "  (The default action if none is provided is '%s')\n" $DEFAULT_ACTION
        msg "  -h --help       - Print this help.\n"
        msg "  -i --info       - Provides information about the package owning a file.\n"
        msg "                    Similar to \`rpm -Qf'.\n"
        msg "  -l --list       - List files similar to \`pacman -Ql'.\n"
        msg "  -r --regex      - Search for a regex instead of a filename.\n"
        msg "  -s --search     - Search for what package owns a file.\n"
        msg "  -u --update     - Update to the latest filelist\n"
        msg "                    This requires write permission for\n"
        msg "                    %s\n" $FILELIST_DIR

        msg "OPTIONS:\n"
        msg "  -b --binaries   - Only show files in a bin/ directory. Works with -s, -l.\n"
        msg "  -c --case-sensitive - Make searches case sensitive.\n"
        msg "  -d --debug      - Increase debug level. This can be passed multiple times.\n"
        msg "  -g --glob       - Allow using * and ? as basic wildcards in a search.\n"
        msg "  -L --limit-rate - Limit wget's data transfer rate when using --update.\n"
        msg "  -R --remote     - Force remote searching instead of using local pacman info.\n"
        msg "  -v --verbose    - Enable verbose output.\n"
#           |--------------------------------------------------------------------------------| 80 Characters
        quit ${1:-0}
}
# }}}

# lock() -- lock $LOCKFILE or die {{{
lock() {
        if [[ -f $LOCKFILE ]]; then
                die 1 "Unable to take lock at %s [pid %d]!\n" "$LOCKFILE" "$(cat "$LOCKFILE")"
        fi
        echo $$ > "$LOCKFILE"
}
# }}}

# unlock() -- remove $LOCKFILE {{{
unlock() {
        rm -f "$LOCKFILE"
}
# }}}

# update() -- update the package file list {{{
update () {
        lock || return 1 # Yeah so lock() dies on fail right now, but maybe not later
        # Ensure that we don't suck when exiting in a non-normal way
        trap 'unlock; die 1 "Caught SIGINT -- aborting!\n"' SIGINT
        trap 'unlock; die 1 "Killed!\n"' SIGTERM

        local target_repo="$1"
        cd_filelist_dir
        local repo_done=()

        (LC_ALL=C pacman --debug  | fgrep 'adding new server' \
                | sed "s|.*adding new server URL to database '\(.*\)': \(.*\)|\1 \2|g"
                ) | while read repo mirror
	do
                (( DEBUG >= 2 )) && set -x

                [[ -n $target_repo ]] && [[ $repo != $target_repo ]] && continue
                in_array "$repo" "${repo_done[@]}" && continue
                [[ -n $REPOS ]] && ! in_array "$repo" "${REPOS[@]}" && continue

                repofile="${repo}.files.tar.gz"
                filelist="${mirror}/${repofile}"

                msg "Updating [%s] file list... " $repo
                vmsg "Trying mirror %s... " $mirror
                if [[ "$mirror" =~ ^file:// ]]; then
                    localfilelist="${filelist#file://}"
                    vmsg "File list is local at %s... " $localfilelist

                    if [[ ! -r "$localfilelist" ]]; then
                        warn "Cannot read local file list %s\n" $localfilelist
                        continue
                    else
                        install -Dm644 "$localfilelist" "$repofile"
                    fi
                else
                    wget -q "$RATELIMIT" "$filelist" -O "$repofile" || { warn "Could not retrieve %s\n" $filelist; continue; }
                fi

                msg "Extracting [%s] file list... " $repo
                mkdir -p "$repo.tmp" || { warn "Could not create temporary directory for %s\n" $repo; continue; }
                tar ozxf "$repofile" -C "$repo.tmp" 2> /dev/null || { warn "Unable to extract %s\n" $repofile; continue; }
                rm -rf "$repo"
                mv "$repo.tmp" "$repo"
                rm -f "$repofile"

                repo_done=( "${repo_done[@]}" "$repo" )
                msg "Done\n"

                (( DEBUG >= 2 )) && set +x
        done
        unlock || warn "Failed to unlock %s" "$LOCKFILE"
        quit 0
}
# }}}

# search() -- find which package owns a file {{{
search () {
        (( DEBUG >= 2 )) && set -x

        local GREP_ARGS=
        (( ! CASE_SENSITIVE )) && GREP_ARGS='-i'

        if (( ! REMOTE_SEARCH )) && [[ $ACTION != 'regex' ]]; then
                if [[ ${1:0:1} == '/' ]]; then
                        if [[ -e $1 && ! -d $1 ]]; then
                                local target="$1"
                        fi
                elif (( BINARIES )); then
                        if which "$1" &>/dev/null; then
                                local target="$(which "$1")"
                        fi
                fi
                if [[ -n $target ]]; then
                        local owner # split this on two lines so `local` doesn't hijack $?
                        owner=$(pacman -Qqo "$target" 2>&1)
                        local ret=$?
                        if (( ret == 0 )); then
                                echo "local/$owner"
                        fi
                        quit $ret
                fi
        fi

        if [[ $ACTION = 'regex' ]]; then
                (( BINARIES )) && warn "Warning: Binary searching cannot be combined with regex search. Ignoring this option\n"
                local fname="$1"
        else
                local fname="$(regex_escape "$1")"
                fname="$(echo "$fname" | sed 's|^/|^|; s|^[^^]|/&|')$"
                # Change a leading / to ^.
                # Change a leading non-^ character to '/$char;
                # This will fix grep's regex to prevent false positives

                # Only search for binaries when we are not given an absolute path, and do not have globbing on.
                if (( BINARIES )) && [[ ${fname:0:1} != '^' ]]; then
                        if (( ! GLOBBING )); then
                                fname="$(echo $fname | sed 's|^/|/s?bin/|')"
                        else
                                warn "Warning: Binary searching cannot be combined with glob search. Ignoring this option\n"
                        fi
                fi
        fi

        cd_filelist_dir noempty

        if (( ! VERBOSE )); then
                local sedstring='s#-[0-9.A-Za-z_]*-[0-9.]*/files:.*##'
        else
                local sedstring='s#-\([0-9.A-Za-z_]*-[0-9.]*\)/files:# (\1) : /#'
        fi

        # */* expanded is really ugly
        (( DEBUG )) && echo "\$fname = '$fname'"
        (( DEBUG >= 2 )) && set +x
        grep $GREP_ARGS -R -E --include="files" "$fname" * | sed "$sedstring" | uniq

        quit 0
}
# }}}

# listfiles() {{{
listfiles () {
        local pkg="$1"
        local FOUNDFILE=0

        if (( ! REMOTE_SEARCH )); then
                if pacman -Q "$pkg" &> /dev/null; then
                        if (( ! BINARIES )); then
                                pacman -Ql "$pkg"
                        else
                                pacman -Ql "$pkg" | grep -E '/s?bin/.'
                        fi
                        return 0
                fi
        fi

        cd_filelist_dir noempty
        pkg_escaped=$(regex_escape "$pkg")
        for repo in *; do
                [[ -d $repo ]] || continue
                (( DEBUG >= 2 )) && set -x
                local findarg="$repo/$pkg_escaped-[^-]+-[^-]+$"
                local findresult="$(\
                        find "$repo" -type d -regex "$findarg" | while read line; do
                                filelist="$line/files"
                                sed -n "1d;s|^|$pkg /|p" "$filelist" | sort # Give it output like pacman -Ql
                        done)"
                if [[ -n $findresult ]]; then
                        FOUNDFILE=1
                        if (( ! BINARIES )); then
                                echo "$findresult"
                        else
                                echo "$findresult" | grep -E '/s?bin/.'
                        fi

                fi
                (( DEBUG >= 2 )) && set +x
        done
        if (( ! FOUNDFILE )); then
                msg "Package '%s' not found\n" "$pkg"
                return 1
        fi
        return 0
}
# }}}

# pkgquery() -- similar to rpm -Qf {{{
pkgquery () {
        local fname="$1"

        # If the file is local we can take some shortcuts to improve speed.
        if [[ -e $fname ]] && (( ! REMOTE_SEARCH )); then
                local pkgname=$(LC_ALL=C pacman -Qqo "$fname" 2>&1)
                if [[ $pkgname =~ 'error: ' ]]; then
                        die 1 'Unable to find package info for file %s\n' "$fname"
                fi
                pkgname=$(echo $pkgname | cut -d' ' -f1)
                pacman -Qi "$pkgname"
        else
                die 1 '%s --info may currently only be used with local files\n' $PROGNAME
        fi

}
# }}}

if [[ -z $1 ]]; then
        usage
fi

# This is mostly a black box to me, I just copy and pasted from makepkg. It seems to work though!
# Thanks to the pacman team for being awesome in so many ways
OPT_SHORT='bcdghiL:lRrsuv'
OPT_LONG='binaries,case-sensitive,debug,glob,help,info,limit-rate:,list,remote,regex,search,update,verbose'
OPT_TEMP="$(getopt -o "$OPT_SHORT" -l "$OPT_LONG" -n "$PROGNAME" -- "$@" || echo 'GETOPT GO BANG!')"
if echo "$OPT_TEMP" | grep -q 'GETOPT GO BANG!'; then
        # This is a small hack to stop the script bailing with 'set -e'
        echo
        usage 1
fi
eval set -- "$OPT_TEMP"
unset OPT_SHORT OPT_LONG OPT_TEMP

while [[ $# -gt 0 ]]; do
        case "$1" in
                -b|--binaries)
                        BINARIES=1
                        ;;
                -c|--case-sensitive)
                        CASE_SENSITIVE=1
                        ;;
                -d|--debug)
                        DEBUG=$(( DEBUG += 1 ))
                        ;;
                -g|--glob)
                        GLOBBING=1
                        ;;
                -h|--help)
                        usage
                        ;;
                -i|--info)
                        ACTION=info
                        ;;
                -L|--limit-rate)
                        RATELIMIT="$2"; shift
                        ;;
                -l|--list)
                        ACTION=list
                        ;;
                -R|--remote)
                        REMOTE_SEARCH=1
                        ;;
                -r|--regex)
                        ACTION=regex
                        ;;
                -s|--search)
                        ACTION=search
                        ;;
                -u|--update)
                        ACTION=update
                        ;;
                -v|--verbose)
                        VERBOSE=1
                        ;;
                --)
                        # It's ok if $2 is empty here, we want null if there's nothing.
                        [[ -z $ACTION ]] && ACTION=$DEFAULT_ACTION
                        SEARCHTARGET="$2"; break
                        ;;
                *)
                        [[ -z $ACTION ]] && ACTION=$DEFAULT_ACTION
                        SEARCHTARGET="$1"
                        ;;
        esac
        shift
done

if [[ -z $SEARCHTARGET && $ACTION != 'update' ]]; then
        die 1 "No target specified to search for!\n"
fi

if [[ -n $RATELIMIT ]]; then
        RATELIMIT="--limit-rate='$RATELIMIT'"
fi

case $ACTION in
        update)
                update "$SEARCHTARGET"
                ;;
        search|regex)
                search "$SEARCHTARGET"
                ;;
        list)
                listfiles "$SEARCHTARGET"
                ;;
        info)
                pkgquery "$SEARCHTARGET"
                ;;
        *)
                die 1 "Invalid \$ACTION '%s' -- This should never happen!\n" "$ACTION"
                ;;
esac

quit 0
# vim: set ts=8 fdm=marker et :
